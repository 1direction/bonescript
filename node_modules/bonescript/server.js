// Copyright (C) 2011 - Texas Instruments, Jason Kridner 
//
// 
var fs = require('fs');
var child_process = require('child_process');
var http = require('http');
var url = require('url');
var path = require('path');
var winston = require('winston');
var b = require('../bonescript');
var socketio = require('socket.io');
var express = require('express');

myrequire('systemd', function() {
    winston.debug("Startup as socket-activated service under systemd not enabled");
});

var port = (process.env.LISTEN_PID > 0) ? 'systemd' : 80;
listen(port, '/usr/share/beaglebone-getting-started/Docs');

function listen(port, directory) {
    var app = express();
    app.use(express.logger('dev'));
    app.use(express.favicon());
    app.get('/bonescript.js', handler);
    app.use(express.static(directory));
    var server = http.createServer(app);
    addSocketListeners(server);
    server.listen(port);
}

function handler(req, res) {
    var parsedUrl = url.parse(req.url);
    var uri = parsedUrl.pathname;
    var host = 'http://' + req.headers['host'];
    if(uri == '/bonescript.js') {
        fs.readFile('bonescript.js', 'utf8', sendFile);
        function sendFile(err, file) {
            if(err) {
                res.writeHead(500, {"Content-Type": "text/plain"});
                res.end(err + '\n');
                return;
            }
            res.setHeader('Content-Type', 'text/javascript');
            file = file.replace(/___INSERT_HOST___/, host);
            res.end(file);
        }
    }
}

function addSocketListeners(server) {
    var io = socketio.listen(server);
    io.set('log level', 2);
    winston.debug('Listening for new socket.io clients');
    io.sockets.on('connection', onconnect);
    function onconnect(socket) {
        winston.debug('Client connected');

        // on disconnect
        socket.on('disconnect', function() {
            winston.debug('Client disconnected');
        });

        var shell = spawn(socket);

        var m = {};
        m.module = 'bonescript';
        m.data = {};
        for(var i in b) {
	    m.data[i] = {};
            m.data[i].name = i;
            m.data[i].type = typeof b[i];
            if(typeof b[i] == 'function') {
                addSocketX(i);
                var fstr = b[i].toString();
                m.data[i].value =
                    fstr.slice(fstr.indexOf('(')+1, fstr.indexOf(')')).match(/([^\s,]+)/g);
            } else {
                m.data[i].value = b[i];
            }
        }
        socket.emit('require', m);

        function addSocketX(name) {
            socket.on(name, onFuncMessage);
            function onFuncMessage(m) {
                callMyFunc(name, m);
                function callMyFunc(name, m) {
                    function callback(resp) {
                        resp = resp || {};
                        if(m && m.seq) resp.seq = m.seq;
                        // TODO: consider setting 'oneshot'
                        socket.emit(name, resp);
                    }
                    try {
                        var callargs = [];
                        for(var arg in b[name].args) {
                            var argname = b[name].args[arg];
                            if(m) {
                                callargs.push(m[argname]);
                            } else {
                                callargs.push(undefined);
                            }
                        }
                        callargs.push(callback);
                        b[name].func.apply(this, callargs);
                    } catch(ex) {
                        winston.debug('Error handing ' + name + ' message: ' + ex);
                        winston.debug('m = ' + JSON.stringify(m));
                    }
                }
            }
        }
    }
}

function myrequire(packageName, onfail) {
    var y = {};
    try {
        y = require(packageName);
        y.exists = true;
    } catch(ex) {
        y.exists = false;
        winston.debug("Optional package '" + packageName + "' not loaded");
        if(onfail) onfail();
    }
    return(y);
}

// most heavily borrowed from https://github.com/itchyny/browsershell
function spawn(socket) {
    var stream = '';
    var timer;
    var len = 0;
    var c;

    socket.on('shell', receive);
    return(receive);

    function receive(msg) {
        if(!c) {
            try {
                winston.debug('Spawning bash');
                c = child_process.spawn('/bin/bash', ['-i'], {customFds: [-1, -1, -1]});
                c.stdout.on('data', send);
                c.stderr.on('data', send);
                c.on('exit', function() {
                    socket.emit('shell', send('\nexited\n'));
                    c = undefined;
                });
                socket.on('disconnect', function () {
                    winston.debug('Killing bash');
                    c.kill('SIGHUP');
                });
            } catch(ex) {
                c = undefined;
                send('Error invoking bash');
                winston.error('Error invoking bash');
            }
        }
        if(c) {
            if(msg) {
                c.stdin.write(msg + '\n', 'utf-8');
            }
        } else {
            winston.error('Unable to invoke child process');
        }
    }

    function send(data) {
       // add data to the stream
       stream += data.toString();
       ++len;

       // clear any existing timeout if it exists
       if(timer) clearTimeout(timer);

       // set new timeout
       timer = setTimeout(function () {
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }, 100);

       // send data if over threshold
       if(len > 1000)
       {
           clearTimeout(timer);
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }
    }
}
