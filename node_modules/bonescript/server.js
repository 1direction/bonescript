// Copyright (C) 2011 - Texas Instruments, Jason Kridner 
//
// 
var fs = require('fs');
var child_process = require('child_process');
var http = require('http');
var url = require('url');
var path = require('path');
var winston = require('winston');
var b = require('.')
var socketio = require('socket.io');

function myrequire(packageName, onfail) {
    var y = {};
    try {
        y = require(packageName);
        y.exists = true;
    } catch(ex) {
        y.exists = false;
        winston.info("Optional package '" + packageName + "' not loaded");
        if(onfail) onfail();
    }
    return(y);
}

function getpin(pin) {
    if(typeof pin == 'object') return(pin);
    else if(typeof pin == 'string') return(bone.pin[pin]);
    else if(typeof pin == 'number') return(bone.pinIndex[pin]);
    else throw("Invalid pin: " + pin);
}

myrequire('systemd', function() {
    winston.info("Startup as socket-activated service under systemd not enabled");
});

// This is a helper function for web servers
var loadFile = function(uri, subdir, res, type) {
    var filename = path.join(subdir, uri);
    path.exists(
        filename,
        function(exists) {
            if(!exists) {
                res.writeHead(404, {"Content-Type": "text/plain"});
                res.write("Error 404: '" + uri + "' Not Found\n");
                res.end();
                return;
            }
            if(type == "binary") {
                fs.readFile(
                    filename,
                    "binary",
                    function(err, file) {
                        if(err) {
                            res.writeHead(500, {"Content-Type": "text/plain"});
                            res.write(err + "\n");
                            res.end();
                            return;
                        }
                        res.writeHead(200);
                        res.write(file, "binary");
                        res.end();
                    }
                );
            } else {
                fs.readFile(
                    filename,
                    'utf8',
                    function(err, file) {
                        if(err) {
                            res.writeHead(500, {"Content-Type": "text/plain"});
                            res.write(err + "\n");
                            res.end();
                            return;
                        }
                        res.writeHead(200, {"Content-Type": type});
                        res.write("" + file);
                        res.end();
                    }
                );
            }
        }
    );
};

// most heavily borrowed from https://github.com/itchyny/browsershell
var spawn = function(socket) {
    var stream = '';
    var timer;
    var len = 0;
    var c;

    var send = function (data) {
       // add data to the stream
       stream += data.toString();
       ++len;

       // clear any existing timeout if it exists
       if(timer) clearTimeout(timer);

       // set new timeout
       timer = setTimeout(function () {
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }, 100);

       // send data if over threshold
       if(len > 1000)
       {
           clearTimeout(timer);
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }
    };

    var receive = function (msg) {
        if(!c) {
            try {
                winston.info('Spawning bash');
                c = child_process.spawn('/bin/bash', ['-i'], {customFds: [-1, -1, -1]});
                c.stdout.on('data', send);
                c.stderr.on('data', send);
                c.on('exit', function() {
                    socket.emit('shell', send('\nexited\n'));
                    c = undefined;
                });
                socket.on('disconnect', function () {
                    winston.info('Killing bash');
                    c.kill('SIGHUP');
                });
            } catch(ex) {
                c = undefined;
                send('Error invoking bash');
                winston.info('Error invoking bash');
            }
        }
        if(c) {
            if(msg) {
                c.stdin.write(msg + '\n', 'utf-8');
            }
        } else {
            winston.info('Unable to invoke child process');
        }
    };
    receive();

    return(receive);
};

var addSocketListeners = function() {};
addSocketListeners = function(server, onconnect) {
    var io = socketio.listen(server);
    io.set('log level', 2);
    winston.info('Listening for new socket.io clients');
    io.sockets.on('connection', function(socket) {
        winston.info('Client connected');

        // on disconnect
        socket.on('disconnect', function() {
            winston.info('Client disconnected');
        });

        var shell = spawn(socket);
        var echo = function(data, callback) {
            winston.info(data);
            callback({'data': data});
        };
        var platform = function(callback) {
            var msg = {'platform': bone};
            if(callback) callback(msg);
            return(msg);
        };

        var myfuncs = {
            'digitalWrite': { func: f.digitalWrite, args: [ 'pin', 'value' ] },
            'digitalRead': { func: f.digitalRead, args: [ 'pin' ] },
            'analogRead': { func: f.analogRead, args: [ 'pin' ] },
            'analogWrite': { func: f.analogWrite, args: [ 'pin', 'value', 'freq' ] },
            'pinMode': { func: f.pinMode, args: [ 'pin', 'direction', 'mux', 'pullup', 'slew' ] },
            'shiftOut': { func: f.shiftOut, args: [ 'dataPin', 'clockPin', 'bitOrder', 'val' ] },
            'attachInterrupt': { func: f.attachInterrupt, args: [ 'pin', 'handler', 'mode' ] },
            'detachInterrupt': { func: f.detachInterrupt, args: [ 'pin' ] },
            'getPinMode': { func: f.getPinMode, args: [ 'pin' ] },
            'getEeproms': { func: f.getEeproms, args: [] },
            'platform': { func: platform, args: [] },
            'shell': { func: shell, args: [ 'command' ] },
            'echo': { func: echo, args: [ 'data' ] },
            'readTextFile': { func: f.readTextFile, args: [ 'filename' ] },
            'writeTextFile': { func: f.writeTextFile, args: [ 'filename', 'data' ] }
        };
        var callMyFunc = function(name, m) {
            var callback = function(resp) {
                resp = resp || {};
                if(m && m.seq) resp.seq = m.seq;
                // TODO: consider setting 'oneshot'
                socket.emit(name, resp);
            };
            try {
                var callargs = [];
                for(var arg in myfuncs[name].args) {
                    var argname = myfuncs[name].args[arg];
                    if(m) {
                        callargs.push(m[argname]);
                    } else {
                        callargs.push(undefined);
                    }
                }
                callargs.push(callback);
                myfuncs[name].func.apply(this, callargs);
            } catch(ex) {
                winston.info('Error handing ' + name + ' message: ' + ex);
                winston.debug('m = ' + JSON.stringify(m));
            }
        };
        var addSocketX = function(name) {
            socket.on(name, function(m) { callMyFunc(name, m); });
        };
        for(var myfunc in myfuncs) {
            addSocketX(myfunc);
        }

        // call user-provided on-connect function
        if(typeof onconnect == 'function')
            onconnect(socket);
    });
};

exports.Server = function(port, subdir, onconnect) {
    port = port || (process.env.LISTEN_PID > 0 ? 'systemd' : 80);
    subdir = path.join(process.cwd(), subdir);
    var handler = function(req, res) {
        var uri = url.parse(req.url).pathname;
        if(uri == '/') {
            loadFile('index.html', subdir, res, "text/html");
        } else {
            if(uri.match(/\.js$/i)) {
                loadFile(uri, subdir, res, "application/javascript");
            } else if(uri.match(/\.css$/i)) {
                loadFile(uri, subdir, res, "text/css");
            } else if(uri.match(/\.htm(.)$/i)) {
                loadFile(uri, subdir, res, "text/html");
            } else if(uri.match(/\.svg$/i)) {
                loadFile(uri, subdir, res, "image/svg+xml");
            } else if(uri.match(/\.(jpg|png|gif|ico)$/i)) {
                loadFile(uri, subdir, res, "binary");
            } else {
                loadFile(uri, subdir, res, "text/plain");
            }
        }
    };
    this.server6 = http.createServer();
    this.server6.addListener('request', handler);
    addSocketListeners(this.server6, onconnect);
    this.server = http.createServer();
    this.server.addListener('request', handler);
    addSocketListeners(this.server, onconnect);
    this.begin = function() {
        this.server6.listen(port, '::0');
        this.server.listen(port);
    };
};
