// Copyright (C) 2011 - Texas Instruments, Jason Kridner
//
//
var fs = require('fs');
var child_process = require('child_process');
var cluster = require('cluster');
var winston = require('winston');
var eeprom = require('./eeprom');
var parse = require('./parse');
var bone = require('./bone');
var functions = require('./functions');

winston.setLevels(winston.config.syslog.levels);
winston.add(winston.transports.File, {
    filename: '/var/lib/cloud9/bonescript.log',
    level: 'info'
});

var file_exists = fs.exists;
var file_existsSync = fs.existsSync;
if(typeof file_exists == 'undefined') {
    var path = require('path');
    file_exists = path.exists;
    file_existsSync = path.existsSync;
}

var f = {};

function myeval(x) {
    winston.debug('eval("' + x + '");');
    var y;
    try {
        y = eval(x);
    } catch(ex) {
        y = undefined;
        winston.error('myeval error: ' + ex);
        throw('myeval error: ' + ex);
    }
    winston.debug('result = ' + y);
    return(y);
}

function myrequire(packageName, onfail) {
    var y = {};
    try {
        y = require(packageName);
        y.exists = true;
    } catch(ex) {
        y.exists = false;
        winston.debug("Optional package '" + packageName + "' not loaded");
        if(onfail) onfail();
    }
    return(y);
}

function getpin(pin) {
    if(typeof pin == 'object') return(pin);
    else if(typeof pin == 'string') return(bone.pins[pin]);
    else if(typeof pin == 'number') return(bone.pinIndex[pin]);
    else throw("Invalid pin: " + pin);
}

var gOUTPUT = "out";
var gINPUT = "in";
var gINPUT_PULLUP = "in_pullup";
var gHIGH = 1;
var gLOW = 0;
var gLSBFIRST = 1;  // used in: shiftOut(dataPin, clockPin, bitOrder, val)
var gMSBFIRST = 0;
var gCHANGE = "both";
var gRISING = "rising";
var gFALLING = "falling";

// Keep track of allocated resources
var gpio = [];
var pwm = [];

// returned object has:
//  mux: index of mux mode
//  options: array of mode names
//  slew: 'fast' or 'slow'
//  rx: 'enabled' or 'disabled'
//  pullup: 'diabled', 'pullup' or 'pulldown'
//  pin: key string for pin
//  name: pin name
f.getPinMode = function(pin, callback) {
    winston.debug('getPinMode(' + pin + ');');
    pin = getpin(pin);
    var mode = {'pin': pin.key, 'name': pin.name};
    if(pin.options) mode.options = pin.options;
    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var pinctrlFile = '/sys/kernel/debug/pinctrl/44e10800.pinmux/pins';
    var muxRegOffset = parseInt(pin.muxRegOffset, 16);
    var readOmapMux = function(err, data) {
        if(err) winston.debug('readOmapMux error: ' + err);
        mode = parse.modeFromOmapMux(data, mode);
        callback(mode);
    };
    var readPinctrl = function(err, data) {
        if(err) winston.debug('readPinctrl error: ' + err);
        mode = parse.modeFromPinctrl(data, muxRegOffset, 0x44e10800, mode);
        callback(mode);
    };
    var tryPinctrl = function(exists) {
        if(exists) {
            fs.readFile(pinctrlFile, 'utf8', readPinctrl);
        } else {
            winston.debug('getPinMode(' + pin.key + '): no valid mux data');
            callback(mode);
        }
    };
    var tryOmapMux = function(exists) {
        if(exists) {
            fs.readFile(muxFile, 'utf8', readOmapMux);
        } else {
            file_exists(pinctrlFile, tryPinctrl);
        }
    };
    if(callback) {
        file_exists(muxFile, tryOmapMux);
    } else {
        try {
            var data = fs.readFileSync(muxFile, 'utf8');
            mode = parse.modeFromOmapMux(data, mode);
        } catch(ex) {
            try {
                var data2 = fs.readFileSync(pinctrlFile, 'utf8');
                mode = parse.modeFromPinctrl(data2, muxRegOffset, 0x44e10800, mode);
            } catch(ex2) {
                winston.debug('getPinMode(' + pin.key + '): ' + ex2);
            }
        }
        return(mode);
    }
};
f.getPinMode.args = ['pin', 'callback'];

f.pinMode = function(pin, direction, mux, pullup, slew, callback) {
    winston.debug('pinMode(' + [pin, direction, mux, pullup, slew] + ');');
    pin = getpin(pin);
    if(direction == gINPUT_PULLUP) pullup = 'pullup';
    pullup = pullup || ((direction == gINPUT) ? 'pulldown' : 'disabled');
    slew = slew || 'fast';
    mux = mux || 7; // default to GPIO mode
    
    if(!pin.mux) {
        winston.debug('Invalid pin object for pinMode: ' + pin);
        throw('Invalid pin object for pinMode: ' + pin);
    }

    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var pinctrlFile = '/sys/kernel/debug/pinctrl/44e10800.pinmux/pins';
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    
    // Handle case where pin is allocated as a gpio-led
    if(pin.led) {
        if((direction != gOUTPUT) || (mux != 7)) {                    
            var err = 'pinMode only supports GPIO output for LEDs: ' + pin.key;
            winston.info(err);
            if(callback) callback({value:false, err:err});
            return(false);
        }
        gpioFile = '/sys/class/leds/beaglebone::' + pin.led + '/brightness';
        var pathA = "/sys/class/leds/beaglebone:";
        var pathB = pathA;
        pathA += ":" + pin.led + "/trigger";
        pathB += "green:" + pin.led + "/trigger";
        if(file_existsSync(pathA)) {
            fs.writeFileSync(pathA, "gpio");
        } else {
            if(file_existsSync(pathB)) {
                fs.writeFileSync(pathB, "gpio");
            } else {
                winston.error("Unable to find LED: " + pin.led);
            }
        }
        gpio[n] = {'path': gpioFile};
        if(callback) callback({value:true});
        return(true);
    }

    // Figure out the desired value
    var pinData = 0;
    if(slew == 'slow') pinData |= 0x40;
    if(direction != gOUTPUT) pinData |= 0x20;
    switch(pullup) {
    case 'disabled':
        pinData |= 0x08;
        break;
    case 'pullup':
        pinData |= 0x10;
        break;
    default:
        break;
    }
    pinData |= (mux & 0x07);
    
    try {
        var fd = fs.openSync(muxFile, 'w');
        fs.writeSync(fd, pinData.toString(16), null);
    } catch(ex) {
        winston.debug('Unable to configure mux for pin ' + pin + ': ' + ex);
        // Don't exit yet --- need to try using pinmux-helper with devicetree
        // ... and it might work if the pin is already muxed to 7
        winston.debug('mode = ' + JSON.stringify(f.getPinMode(pin)));
        var currentMode = f.getPinMode(pin);
        if(currentMode.mux != mux) {
            var err = 'Unable to configure mux for pin ' + pin.key + ': ' + ex;
            winston.info(err);
            gpio[n] = {};
            if(callback) callback({value:false, err:err});
            return(false);
        }
    }

    // Enable GPIO, if not already done
    var n = pin.gpio;
    if(mux == 7) {
        if(!gpio[n] || !gpio[n].path) {
            gpio[n] = {'path': gpioFile};
    
            // Export the GPIO controls
            var exists = file_existsSync(gpioFile);
            if(exists) {
                winston.debug("gpio: " + n + " already exported.");
                fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                    direction, null);
            } else {
                try {
                    winston.debug("exporting gpio: " + n);
                    fs.writeFileSync("/sys/class/gpio/export", "" + n, null);
                    winston.debug("setting gpio " + n +
                        " direction to " + direction);
                    fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                        direction, null);
                } catch(ex2) {
                    var err = 'Unable to export gpio-' + n + ': ' + ex2;
                    winston.debug(err);
                    var gpioUsers =
                        fs.readFileSync('/sys/kernel/debug/gpio', 'utf-8');
                    gpioUsers = gpioUsers.split('\n');
                    for(var x in gpioUsers) {
                        var y = gpioUsers[x].match(/gpio-(\d+)\s+\((\S+)\s*\)/);
                        if(y && y[1] == n) {
                            var err2 = 'gpio-' + n + ' consumed by ' + y[2];
                            err += '\n' + err2;
                            winston.error(err2);
                        }
                    }
                    gpio[n] = {};
                    if(callback) callback({value:false, err:err});
                    return(false);
                }
            }
        }
    } else {
        gpio[n] = {};
    }
    
    if(callback) callback({value:true});
    return(true);
};
f.pinMode.args = ['pin', 'direction', 'mux', 'pullup', 'slew', 'callback'];

f.digitalWrite = function(pin, value, callback) {
    winston.debug('digitalWrite(' + [pin, value] + ');');
    pin = getpin(pin);
    value = parseInt(value, 2) ? 1 : 0;
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(pin.led) {
        var pathA = "/sys/class/leds/beaglebone:";
        var pathB = pathA;
        pathA += ":" + pin.led + "/brightness";
        pathB += "green:" + pin.led + "/brightness";
        if(file_existsSync(pathA)) {
            gpioFile = pathA;
        } else {
            if(file_existsSync(pathB)) {
                gpioFile = pathB;
            } else {
                winston.error("Unable to find LED: " + pin.led);
            }
        }
    }
    winston.debug("gpioFile = " + gpioFile);
    if(callback) {
        fs.writeFile(gpioFile, '' + value, null, callback);
    } else {
        try {
            fs.writeFileSync(gpioFile, '' + value, null);
        } catch(ex) {
            winston.error("Unable to write to " + gpioFile);
        }
    }
    return(true);
};
f.digitalWrite.args = ['pin', 'value', 'callback'];

f.digitalRead = function(pin, callback) {
    winston.debug('digitalRead(' + [pin, value] + ');');
    pin = getpin(pin);
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(callback) {
        var readFile = function(err, data) {
            if(err) winston.error('digitalRead error: ' + err);
            var value = parseInt(data, 2);
            callback({'value':value});
        };
        fs.readFile(gpioFile, readFile);
        return(true);
    }
    var value = parseInt(fs.readFileSync(gpioFile), 2);
    return(value);
};
f.digitalRead.args = ['pin', 'callback'];

f.analogRead = function(pin, callback) {
    if(!this.filePrefix) {
        var prefix_new = '/sys/module/bone_iio_helper/drivers/platform\:bone-iio-helper/helper.11/AIN';
        var prefix_old = '/sys/bus/platform/devices/tsc/ain';
        if(file_existsSync(prefix_new + '0')) {
            this.filePrefix = prefix_new;
            this.indexOffset = 0;
            this.scale = 1800;
        } else {
            this.filePrefix = prefix_old;
            this.indexOffset = 1;
            this.scale = 4096;
        }
    }
    winston.debug('analogRead(' + [pin] + ');');
    pin = getpin(pin);
    var ainFile = this.filePrefix + (pin.ain + this.indexOffset);
    if(callback) {
        var readFile = function(err, data) {
            if(err) winston.error('analogRead error: ' + err);
            var value = parseInt(data, 10) / this.scale;
            callback({'value': value});
        };
        fs.readFile(ainFile, readFile);
        return(true);
    }
    var data = parseInt(fs.readFileSync(ainFile), 10);
    if(isNaN(data)) {
        throw('analogRead(' + pin.key + ') returned ' + data);
    }
    data = data / this.scale;
    if(isNaN(data)) {
        throw('analogRead(' + pin.key + ') scaled to ' + data);
    }
    return(data);
}; 
f.analogRead.args = ['pin', 'callback'];

f.shiftOut = function(dataPin, clockPin, bitOrder, val, callback) {
    winston.debug('shiftOut(' + [pin, clockPin, bitOrder, val] + ');');
    pin = getpin(pin);
  var i;
  var bit;
  for (i = 0; i < 8; i++)  
  {
    if (bitOrder == gLSBFIRST) 
    {
         bit = val & (1 << i);
    } else
    {
         bit = val & (1 << (7 - i));
    }

    f.digitalWrite(dataPin, bit);
    f.digitalWrite(clockPin, gHIGH);
    f.digitalWrite(clockPin, gLOW);
    if(callback) callback();
  }
};
f.shiftOut.args = ['dataPin', 'clockPin', 'bitOrder', 'val', 'callback'];

f.attachInterrupt = function(pin, handler, mode, callback) {
    pin = getpin(pin);
    if(!gpio[pin.gpio]) {
        if(callback) callback({'pin':pin, 'attached':false, 'configured':false});
        return(false);
    }
    if(gpio[pin.gpio].intProc) {
        if(callback) callback({'pin':pin, 'attached':false, 'configured':true});
        return(false);
    }
    winston.debug('Adding handler ' + handler + ' to pin ' + pin.key);
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    fs.writeFileSync('/sys/class/gpio/gpio' + pin.gpio + '/edge', mode);
    handler = (typeof handler === "string") ? myeval('(' + handler + ')') : handler;
    var intHandler = function(m) {
        var output = handler({'pin':pin, 'value':m.value});
        if(output && callback) callback({'pin':pin, 'output':output});
    };
    var intProc;
    if(child_process.fork) {
        intProc = child_process.fork(__dirname + '/gpioint.js');
    } else {
        var fork = require('fork');
        intProc = fork.fork(__dirname + '/gpioint.js');
    }
    intProc.on('message', intHandler);
    intProc.on('exit', function(code, signal) {
        if(callback) callback({
            'pin':pin,
            'code':code,
            'signal':signal,
            'died':true
        });
    });
    intProc.send({'pin':pin, 'mode':mode, 'file':gpioFile});
    gpio[pin.gpio].intProc = intProc;
    process.on('SIGTERM', function() {
        intProc.kill();
        if(callback) callback({'pin':pin, 'died':true});
    });
    if(callback) callback({'pin':pin, 'attached':true});
    return(true);
};
f.attachInterrupt.args = ['pin', 'hander', 'mode', 'callback'];

f.detachInterrupt = function(pin, callback) {
    pin = getpin(pin);
    if(!gpio[pin.gpio] || !gpio[pin.gpio].intProc) {
        if(callback) callback({'pin':pin, 'detached':false});
        return(false);
    }
    gpio[pin.gpio].intProc.kill();
    delete gpio[pin.gpio].intProc;
    if(callback) callback({'pin':pin, 'detached':true});
};
f.detachInterrupt.args = ['pin', 'callback'];

// See http://processors.wiki.ti.com/index.php/AM335x_PWM_Driver's_Guide
f.analogWrite = function(pin, value, freq, callback) {
    pin = getpin(pin);
    freq = freq || 1000;
    var path = '/sys/class/pwm/' + pin.pwm.path;
    //var curMode = getPinMode(pin);
    // Not yet possible to implement this test
    //if(curMode.direction != OUTPUT) {
    //    throw(pin.key + ' must be configured as OUTPUT for analogWrite()');
    //}
    if(!pin.pwm) {
        throw(pin.key + ' does not support analogWrite()');
    }
    if(pwm[pin.pwm.path] && pwm[pin.pwm.path].key) {
        if(pwm[pin.pwm.path].key != pin.key) {
            throw(pin.key + ' requires pwm ' + pin.pwm.name +
                ' but it is already in use by ' +
                pwm[pin.pwm].key
            );
         }
    } else {
        pwm[pin.pwm.path] = {};
        pwm[pin.pwm.path].key = '' + pin.key;
        pwm[pin.pwm.path].freq = freq;
        f.pinMode(pin, gOUTPUT, pin.pwm.muxmode, 'disabled', 'fast');

        // Clear up any unmanaged usage
        fs.writeFileSync(path+'/request', '0');

        // Allocate and configure the PWM
        fs.writeFileSync(path+'/request', '1');
        fs.writeFileSync(path+'/period_freq', freq);
        fs.writeFileSync(path+'/polarity', '0');
        fs.writeFileSync(path+'/run', '1');
    }
    if(pwm[pin.pwm.path].freq != freq) {
        fs.writeFileSync(path+'/run', '0');
        fs.writeFileSync(path+'/duty_percent', '0');
        fs.writeFileSync(path+'/period_freq', freq);
        fs.writeFileSync(path+'/run', '1');
        pwm[pin.pwm.path].freq = freq;
    }
    fs.writeFileSync(path+'/duty_percent', Math.round(value*100));
    if(callback) callback();
};
f.analogWrite.args = ['pin', 'value', 'freq', 'callback'];

f.getEeproms = function(callback) {
    var eeproms = {};
    if(!file_existsSync('/sys/devices/bone_capemgr.8/baseboard/board-name')) {
        var EepromFiles = {
            '/sys/bus/i2c/drivers/at24/1-0050/eeprom': { type: 'bone' },
            '/sys/bus/i2c/drivers/at24/3-0054/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0055/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0056/eeprom': { type: 'cape' },
            '/sys/bus/i2c/drivers/at24/3-0057/eeprom': { type: 'cape' }
        };
        eeproms = eeprom.readEeproms(EepromFiles);
        if(eeproms == {}) {
            winston.debug('No valid EEPROM contents found');
        }
    } else {
        var boardName = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/board-name', 'ascii');
        var version = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/revision', 'ascii');
        var serialNumber = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/serial-number', 'ascii');
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'] = {};
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].boardName = boardName;
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].version = version;
        eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].serialNumber = serialNumber;
    }
    if(callback) {
        callback(eeproms);
    }
    return(eeproms);
};
f.getEeproms.args = ['callback'];

f.readTextFile = function(filename, callback) {
    var cb = function(err, data) {
        callback({'err':err, 'data':data});
    };
    fs.readFile(filename, 'ascii', cb);
};
f.readTextFile.args = ['filename', 'callback'];

f.writeTextFile = function(filename, data, callback) {
    var cb = function(err) {
        callback({'err':err});
    };
    fs.writeFile(filename, data, 'ascii', cb);
};
f.writeTextFile.args = ['filename', 'data', 'callback'];

f.getPlatform = function(callback) {
    var platform = {'platform': bone, 'name': "BeagleBone", 'bonescript': "0.2"};
    if(file_existsSync('/sys/devices/bone_capemgr.8/baseboard/board-name')) {
        platform.name = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/board-name', 'ascii').trim();
        if(platform.name == 'A335BONE') platform.name = 'BeagleBone';
        if(platform.name == 'A335BNLT') platform.name = 'BeagleBone Black';
        platform.version = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/revision', 'ascii').trim();
        if(!platform.version.match(/^[\040-\176]*$/)) delete platform.version;
        platform.serialNumber = fs.readFileSync('/sys/devices/bone_capemgr.8/baseboard/serial-number', 'ascii').trim();
        if(!platform.serialNumber.match(/^[\040-\176]*$/)) delete platform.serialNumber;
    }
    if(callback) callback(platform);
    return(platform);
}
f.getPlatform.args = ['callback'];

f.echo = function(data, callback) {
    winston.info(data);
    callback({'data': data});
    return(data);
}
f.echo.args = ['data', 'callback'];

// Exported variables
exports.OUTPUT = gOUTPUT;
exports.INPUT = gINPUT;
exports.INPUT_PULLUP = gINPUT_PULLUP;
exports.HIGH = gHIGH;
exports.LOW = gLOW;
exports.LSBFIRST = gLSBFIRST;
exports.MSBFIRST = gMSBFIRST;
exports.CHANGE = gCHANGE;
exports.RISING = gRISING;
exports.FALLING = gFALLING;
exports.bone = bone; // this likely needs to be platform and be detected
for(var x in f) {
    exports[x] = f[x];
}
for(var x in functions) {
    exports[x] = functions[x];
}

// Global variable assignments
// This section is broken out because it will eventually be deprecated
var needsToRun = true;
function setGlobals() {
    for(var x in exports) {
        global[x] = exports[x];
    }
    function run() {
        if(!needsToRun) return(false);
        needsToRun = false;
        f.run(setup, loop); // these are globals that may or may not be defined
    }
    process.nextTick(run);
}
exports.setGlobals = setGlobals;
